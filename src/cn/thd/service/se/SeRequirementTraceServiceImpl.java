package cn.thd.service.se;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;

import org.springframework.stereotype.Service;

import cn.thd.bean.EasyUiTreeBean;
import cn.thd.bean.StaticVar;
import cn.thd.pojo.se.SeRequirementTrace;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.thd.core.dao.JdbcDao;
import com.thd.core.dao.PubDao;
import com.thd.core.service.PubServiceImpl;
import com.thd.util.ListUtil;
import com.thd.util.MyListUtils;
import com.thd.util.MyStringUtils;
import com.thd.util.Page;
import com.thd.util.StringUtil;
import com.thd.util.TreeUtil;
/**
 * file autogenerated by ThirdteenDevils's CodeGenUtil 
 */
@Service("seRequirementTraceService")
public class SeRequirementTraceServiceImpl extends PubServiceImpl implements SeRequirementTraceService {
	@Resource 
	private PubDao pubDao;
	@Resource
	private JdbcDao jdbcDao;

	@Override
	public SeRequirementTrace queryNodeById(String nodeId) {
		return (SeRequirementTrace)this.pubDao.findById(SeRequirementTrace.class, nodeId);
	}

	@Override
	public String queryTreeCodeById(String nodeId) {
		return ((SeRequirementTrace)this.pubDao.findById(SeRequirementTrace.class, nodeId)).getTreeCode();
	}
	
	@Override
	public SeRequirementTrace queryNodeByTreeCode(String treeCode){
		String hql = " from SeRequirementTrace t where t.treeCode = '" + treeCode + "'";
		List l = this.pubDao.findByHql(hql);
		if(ListUtil.isNotEmpty(l)){
			return (SeRequirementTrace)l.get(0);
		}else{
			return null;
		}
	};

	@Override
	public SeRequirementTrace queryRoot(String projectId) {
		String sql = "select trace_id from se_requirement_trace where tree_code = '00000' ";
		
		if(MyStringUtils.isNotEmpty(projectId)){
			sql += "and project_id = '" + projectId + "'";
		}
		List l = this.pubDao.findBySql(sql);
		if(ListUtil.isNotEmpty(l)){
			Object obj = ListUtil.getOne(l);
			String id = obj.toString();
			return this.queryNodeById(id);
		}
		return null;
	}
	@Override
	public String queryRootJson(String projectId){
		SeRequirementTrace trace = this.queryRoot(projectId);
		
		Map<String,String> m = this.converterSeRequirementTractToNode(trace);
		
		StringBuffer json = new StringBuffer();
		GsonBuilder builder = new GsonBuilder();
		Gson gson = builder.setDateFormat("yyyy-MM-dd").create();
		String listStr = gson.toJson(m);
		return "[" + listStr + "]";
	}; 

	@Override
	public List queryNextNodeByCode(String code,String projectId) {
		//String hql = "from SeRequirementTrace t where t.treeCode like '" + code + ".%' and t.treeCode not like '" + code + ".%.%' and t.projectId = '" + projectId + "'  order by t.traceOrder ";
		//return this.pubDao.findByHql(hql);
		
		String sql = "select "+ 
				" t.trace_id as id , "+ 
				" t.trace_name as text "+ 
				" from se_requirement_trace t where 1=1"+
				" and t.tree_code like ? "+
				" and t.tree_code not like ? "+
				" and t.project_id = ? "+
				"  order by t.trace_order  ";
		List params = new ArrayList();
		params.add(code + ".%");
		params.add(code + ".%.%");
		params.add(projectId);
		return this.jdbcDao.query(sql, params.toArray(), null);
		
	}
	@Override
	public List queryChildNodeByCode(String code){
		String hql = "from SeRequirementTrace t where t.treeCode like '" + code + ".%'  order by t.treeCode ";
		return this.pubDao.findByHql(hql);
	};
	@Override
	public SeRequirementTrace queryParentNode(String id){
		SeRequirementTrace node = this.queryNodeById(id);
		if(node == null){
			throw new RuntimeException("未找到矩阵节点");
		}
		if(StringUtil.isEmpty(node.getTreeCode())){
			throw new RuntimeException("未找到矩阵树形代码");
		}
		String code = node.getTreeCode();
		
		String parentTreeCode = TreeUtil.parentCode(code);
		return this.queryNodeByTreeCode(parentTreeCode);
	};
	@Override
	public List queryNextNodeById(String id) {
		SeRequirementTrace trace = this.queryNodeById(id);
		return queryNextNodeByCode(trace.getTreeCode(),trace.getProjectId());
	}

	@Override
	public String queryNextNodeJsonById(String id) {
		List l = this.queryNextNodeById(id);
		if(ListUtil.isNotEmpty(l)){
			
			List<Map<String,String>> r = new ArrayList<Map<String,String>>();
			for(Object obj : l){
				Map node = (Map)obj;
				SeRequirementTrace trace = this.querySeRequirementTraceById(node.get("id").toString());
				Map<String,String> m = this.converterSeRequirementTractToNode(trace);
				if(StringUtil.isNotEmpty(id)){
					m.put("parentId", id);
				}else{
					m.put("parentId","root");
				}
				r.add(m);
			}
			
			StringBuffer json = new StringBuffer();
			GsonBuilder builder = new GsonBuilder();
			Gson gson = builder.setDateFormat("yyyy-MM-dd").create();
			String listStr = gson.toJson(r);
			return listStr;
		}else{
			return "[]";
		}
	}
	@Override
	public Map<String,String> converterSeRequirementTractToNode(SeRequirementTrace trace){
		Map<String,String> m = new HashMap<String,String>();
		m.put("id", trace.getTraceId());
		m.put("text",trace.getTraceName());
		if(!"1".equals(trace.getIsLeaf())){
			m.put("state","closed");
		}
		return m;
	}
	@Override
	public SeRequirementTrace createNewNode(String parentNodeId){
		SeRequirementTrace parentTrace = (SeRequirementTrace)this.findById(SeRequirementTrace.class,parentNodeId);
		if(parentTrace == null){
			throw new RuntimeException("未找到ID为[" + parentNodeId + "]的矩阵");
		}
		SeRequirementTrace st = new SeRequirementTrace();
		String treeCode = this.makeChildCode(parentTrace.getTreeCode());
		st.setProjectId(parentTrace.getProjectId());
		st.setTraceName("新建矩阵节点");
		st.setTreeCode(treeCode);
		st.setIsLeaf("1");
		st.setIsValid("1");
		st.setCreateTime(new Date());
		st.setUpdateTime(new Date());
		st.setIsDelete(StaticVar.ISDELETE_UNDELETE);
		st.setParentId(parentNodeId);
		this.pubDao.save(st);
		//更新父节点变为非叶子节点
		parentTrace.setIsLeaf("0");
		this.pubDao.update(parentTrace);
		return st;
	};
	@Override
	public String saveNode(String parentNodeId, SeRequirementTrace trace) {
		return null;
	}

	@Override
	public String updateNode(SeRequirementTrace trace) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String deleteNode(String nodeId) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String moveNode(String targetId, String sourceId, String point) {
		System.out.println("...");
		if(!"append".equals(point) && !"top".equals(point) && !"bottom".equals(point)){
			return "failure";
		}
		
		//源节点
		SeRequirementTrace sourceNode = this.queryNodeById(sourceId);
		//原目标节点树码
		String sourceTreeCode = sourceNode.getTreeCode();
		//目标节点
		SeRequirementTrace targetNode = this.queryNodeById(targetId);
		//目标节点树码
		String targetTreeCode = targetNode.getTreeCode();
		if("append".equals(point)){
			/*
			 * A节点移动到B节点内部主要算法,例子数据如下：
			 *  |__________________________________________________________________________|
			 *  |  树码                                                 |         节点                         |  节点名称                |
			 *  |__________________________________________________________________________|
			 *  |  00000                       |         root            |    根节点                |             
			 *  |  00000.00001                 |           |-root.A      |    A节点                 |              
			 *  |  00000.00001.00001           |           |  |-root.A.1 |    A节点的字节点   |                        
			 *  |  00000.00002.00003           |           |-root.B      |    B节点                 |                                     
			 *  |  00000.00002.00003.00001     |              |-root.B.1 |    B节点的字节点   |                        
			 *  |__________________________________________________________________________|
			 *  
			 * 获取B节点下最大的树码的最后一个码段     => 00000.00002.00003.00001
			 * 生成A节点的新的码段 => 00000.00002.00003.00002
			 * 将A节点及A所有子节点的树码 的与A节点树码相同的部分替换为A节点的新树码  
			 *     00000.00001 => 00000.00002.00003.00002      
			 *     -----------
			 *          |
			 *         \/
			 *     00000.00002.00003.00002
			 *     
			 *             
			 *     00000.00001.00001 => 00000.00002.00003.00002.00001  
			 *     -----------
			 *          |   
			 *         \/ 
			 *     00000.00002.00003.00002                 
			 *                                 
			 */
			
			//新树码
			String newSourceCode = this.makeChildCode(targetTreeCode);
			//更新源节点
			sourceNode.setTreeCode(newSourceCode);
			this.pubDao.update(sourceNode);
			//更新源节点的子节点
			List sourceChildNodes = this.queryNextNodeByCode(sourceTreeCode,sourceNode.getProjectId());
			if(ListUtil.isNotEmpty(sourceChildNodes)){
				for(Object obj : sourceChildNodes){
					SeRequirementTrace node = (SeRequirementTrace)obj;
					String childTreeCode = node.getTreeCode();
					childTreeCode = childTreeCode.replace(sourceTreeCode, newSourceCode);
					node.setTreeCode(childTreeCode);
					this.pubDao.update(node);
				}
			}
			return "success";
		}else{
			
			/*
			 *  A节点移动到B节点上方或下方算法,例子数据如下：
			 *  
			 *  |__________________________________________________________________________|
			 *  |  树码                                                 |         节点                         |  节点名称                |
			 *  |__________________________________________________________________________|
			 *  |  00000                       |         root            |    根节点                |             
			 *  |  00000.00001                 |           |-root.A      |    A节点                 |              
			 *  |  00000.00001.00001           |           |  |-root.A.1 |    A节点的子节点   |  
			 *  |  00000.00002                 |           |-root.BPARENT|    B节点的父节点   |
			 *  |  00000.00002.00003           |           |-root.B      |    B节点                 |                                     
			 *  |  00000.00002.00003.00001     |           |   |-root.B.1|    B节点的子节点   | 
			 *  |  00000.00002.00004           |           |-root.C      |    C节点                 |
			 *  |  00000.00002.00004.00001     |               |-root.C.1|    C节点的子节点   | 
			 *  |__________________________________________________________________________|
			 *  
			 *  获取B节点父节点的树码
			 *  获取B节点最后码段的整数型  00000.00002.00003 -> 3
			 *  获取A节点最后码段的整数型  00000.00001 -> 1
			 *  计算出A节点的新树码
			 *     如果移动到B节点上方，则取根据B节点树码最后码段的整数值(00000.00002.00003 -> 3)，如果是移动到B节点下方则取B节点树码最后码段的整数值+1 (00000.00002.00003 -> 3+1 = 4)
			 *     根据上部的值计算A节点移动后树码最后的码段(如果移动到B节点上方则为 00003 ， 如果移动到B节点下方则为 00004)
			 *     A节点新树码为B父节点的树码+刚计算出的A节点最后的码段  
			 *         B父节点的树码：00000.00002
			 *         A节点新数码：00000.00002 + 00003(移动B上方) 00004(移动到B下方)  => 00000.00002.00003(移动到B上方)      00000.00002.00004(移动到B下方) 
			 *     将A节点及其子节点的树码批量替换
			 *         遍历所有节点，将与A节点相同的部分替换为A节点的新树码  
			 *             例如A节点树码00000.00001-> 00000.00002.00003(移动到B上方)      00000.00001-> 00000.00002.00004(移动到B下方)
			 *             A节点子节点树码：00000.00001.00001->00000.00002.00003.00001(移动到B上方)   00000.00001.00001->00000.00002.00003.00004(移动到B下方)
			 *                            -----------                                              -----------
			 *                                 |                                                        |
			 *                                 \/                                                       \/
			 *                           00000.00002.00003                                        00000.00002.00003
			 *         遍历所有节点，将新树码前面加入"temp."避免下面调整树码时与A或A子节点的移动前树码相同(此操作应特别注意！！！！！！！！！！！！！！！！！！！！！！！！)
			 *         
			 *  
			 *  如果移动B节点上方，找到所有B父节点下的子节点(包含B子孙节点) 且 树码大于或等于B的树码 且 非A节点 且 非A节点及A节点子节点的所有节点集合(此集合命名为X)
			 *  如果移动B节点下方，找到所有B父节点下的子节点(包含B子孙节点) 且 树码大于B的树码 且 非B的子孙节点 且 非A节点及A节点子节点的所有节点集合 (此集合命名为X)
			 *  将X集合中所有子节点执行以下操作
			 *      取出节点树码中 将树码中长度和B节点树码长度相同的部分，并将该部分树码的最后码段取整数后加1,并形成码段  例如
			 *          B的子节点 00000.00002.00003.00001 -> 00000.00002.00003 ->3 + 1 -> 4 ->00004
			 *          C节点的子节点00000.00002.00004.00001->00000.00002.00004->4 + 1 -> 5 ->00005
			 *      将该节点原树码与B节点原树码长度相同的内容替换成 B父节点树码+上面生成的码段 例如：
			 *          B的子节点 00000.00002.00003.00001 -> 00000.00002.00004.00001
			 *          C节点的子节点00000.00002.00004.00001->00000.00002.00005.00001
			 *   
			 *   
			 *   A及A的子节点还原成最终数码(将所有temp.开头的节点去掉temp)
			 */
			
			//目标节点父节点 
			String targetTreeParentCode = TreeUtil.parentCode(targetTreeCode);
			//目标节点父节点树码
			SeRequirementTrace targetParentNode = this.queryNodeByTreeCode(targetTreeParentCode);
			//查询所有比目标节点大的节点
			int newCodeNo = TreeUtil.getCount(targetTreeCode);
			int sourceCodeNo = TreeUtil.getCount(sourceTreeCode);
			
			
			
			String operator = "";
			int newCodeNoTemp = newCodeNo;
			String hql = "";
			String queryTreeCode = targetTreeParentCode + "." + TreeUtil.createCode("00000", newCodeNo);
			if("top".equals(point)){
				operator = ">=";
				hql = "from SeRequirementTrace t where t.treeCode " + operator + " '" + queryTreeCode + "' and t.treeCode like '" + targetTreeParentCode + ".%' and  t.treeCode not like '" + sourceTreeCode + "%'";
				
			}else{
				operator = ">";
				hql = "from SeRequirementTrace t where t.treeCode " + operator + " '" + queryTreeCode + "' and t.treeCode not like '" + queryTreeCode + ".%' and t.treeCode like '" + targetTreeParentCode + ".%' and  t.treeCode not like '" + sourceTreeCode + "%'";
				
				newCodeNoTemp = newCodeNo+1;
			}
			
			
			//源节点新树码最后一段代码
			String newCodeLastCode = TreeUtil.createCode("00000", newCodeNoTemp);
			//源节点新树码
			String newSourceCode = targetTreeParentCode + "." + newCodeLastCode;
			
			
			//更新源节点及其子节点
			String hql_update_tmp = "from SeRequirementTrace t where t.treeCode like '" + sourceTreeCode + "%'";
			
			List sourceChildNodes = this.pubDao.findByHql(hql_update_tmp);
			if(ListUtil.isNotEmpty(sourceChildNodes)){
				for(Object obj : sourceChildNodes){
					SeRequirementTrace node = (SeRequirementTrace)obj;
					String childTreeCode = node.getTreeCode();
					childTreeCode = childTreeCode.replace(sourceTreeCode, newSourceCode);
					node.setTreeCode("temp."+childTreeCode);
					this.pubDao.update(node);
				}
			}
			
			
			List gtTargetNode = this.pubDao.findByHql(hql);
			if(ListUtil.isNotEmpty(gtTargetNode)){
				for(Object obj : gtTargetNode){
					SeRequirementTrace node = (SeRequirementTrace)obj;
					String codeTemp_1 = node.getTreeCode();
					String codeTemp_2 = codeTemp_1.substring(0,targetTreeCode.length());
					int codeNoTemp = TreeUtil.getCount(codeTemp_2);
					codeNoTemp++;
					String codeTemp_3 = TreeUtil.createCode("00000", codeNoTemp);
					String codeTemp_4 = targetTreeParentCode+"."+codeTemp_3;
					
					String newTreeCode = codeTemp_1.replace(codeTemp_2, codeTemp_4);
					node.setTreeCode(newTreeCode);
					this.pubDao.update(node);
				}
			}
			
			//更新源节点及其子节点
			String hql_1 = "from SeRequirementTrace t where t.treeCode like '" + sourceTreeCode + "%'";
			
			//更新源节点及其子节点
			String hql_update_tmp_1 = "from SeRequirementTrace t where t.treeCode like 'temp.%'";
			
			List sourceTempChildNodes = this.pubDao.findByHql(hql_update_tmp_1);
			if(ListUtil.isNotEmpty(sourceTempChildNodes)){
				for(Object obj : sourceTempChildNodes){
					SeRequirementTrace node = (SeRequirementTrace)obj;
					String childTreeCode = node.getTreeCode();
					childTreeCode = childTreeCode.replace("temp.", "");
					node.setTreeCode(childTreeCode);
					this.pubDao.update(node);
				}
			}
			return "success";
		}
	}

	@Override
	public String queryMaxTreeCode(String code) {
		String sql = "select tree_code from se_requirement_trace where tree_code like '" + code + ".%' and tree_code not like '" + code + ".%.%' order by tree_code desc";
		List l = this.pubDao.findBySql(sql);
		if(ListUtil.isNotEmpty(l)){
			return l.get(0).toString();
		}else{
			return null;
		}
	}
	
	

	@Override
	public String makeChildCode(String code) {
		String str = "";
		String maxCode = this.queryMaxTreeCode(code);
		int ct = 1;
		if(StringUtil.isNotEmpty(maxCode)){
			ct = TreeUtil.getCount(maxCode) + 1;
		}
		code = code + "." + TreeUtil.createCode("00000", ct);
		return code;
	};
	
	/*
	 * (non-Javadoc)
	 * @see cn.thd.service.se.SeRequirementTraceService#querySeRequirementTrace(java.util.Map, com.ccse.hr.util.Page)
	 */
	public List querySeRequirementTrace(Map<String,String> m , Page p){
		List<String> param = new ArrayList<String>();
		
		String sql = "select "+
			" t.TRACE_ID as TRACE_ID, " + //0  矩阵ID 
			" t.PROJECT_ID as PROJECT_ID, " + //0 项目ID 			
			" t.TRACE_NO as TRACE_NO, " + //1 矩阵编号 			
			" t.TRACE_NAME as TRACE_NAME, " + //2 矩阵名称 			
			" t.TREE_CODE as TREE_CODE, " + //3 树形目录代码 			
			" t.IS_LEAF as IS_LEAF, " + //4 是否叶子节点 			
			" t.TRACE_ORDER as TRACE_ORDER, " + //5 排序号 			
			" t.IS_VALID as IS_VALID, " + //6 是否有效 			
			" t.IS_DELETE as IS_DELETE, " + //7 是否删除 			
			" t.CREATE_TIME as CREATE_TIME, " + //8 创建时间 			
			" t.UPDATE_TIME as UPDATE_TIME " + //9 更新时间 			
			
			" from SE_REQUIREMENT_TRACE t  where 1=1 ";
		
		if(m!=null){
			if(StringUtil.isNotEmpty(m.get("TRACE_ID"))){
				sql += " and t.TRACE_ID like ? ";
				param.add("%" + m.get("TRACE_ID").toString().trim() + "%");
			}
				if(StringUtil.isNotEmpty(m.get("PROJECT_ID"))){
					sql += " and upper(t.PROJECT_ID) like upper(?) ";
					param.add("%" + m.get("PROJECT_ID").toString().trim() + "%");
				}
				if(StringUtil.isNotEmpty(m.get("TRACE_NO"))){
					sql += " and upper(t.TRACE_NO) like upper(?) ";
					param.add("%" + m.get("TRACE_NO").toString().trim() + "%");
				}
				if(StringUtil.isNotEmpty(m.get("TRACE_NAME"))){
					sql += " and upper(t.TRACE_NAME) like upper(?) ";
					param.add("%" + m.get("TRACE_NAME").toString().trim() + "%");
				}
				if(StringUtil.isNotEmpty(m.get("TREE_CODE"))){
					sql += " and upper(t.TREE_CODE) like upper(?) ";
					param.add("%" + m.get("TREE_CODE").toString().trim() + "%");
				}
				if(StringUtil.isNotEmpty(m.get("IS_LEAF"))){
					sql += " and upper(t.IS_LEAF) like upper(?) ";
					param.add("%" + m.get("IS_LEAF").toString().trim() + "%");
				}
				if(StringUtil.isNotEmpty(m.get("TRACE_ORDER"))){
					sql += " and t.TRACE_ORDER = ? ";
					param.add(m.get("TRACE_ORDER").toString().trim());
				}
				if(StringUtil.isNotEmpty(m.get("IS_VALID"))){
					sql += " and upper(t.IS_VALID) like upper(?) ";
					param.add("%" + m.get("IS_VALID").toString().trim() + "%");
				}
				if(StringUtil.isNotEmpty(m.get("IS_DELETE"))){
					sql += " and upper(t.IS_DELETE) like upper(?) ";
					param.add("%" + m.get("IS_DELETE").toString().trim() + "%");
				}
				if(StringUtil.isNotEmpty(m.get("CREATE_TIME"))){
					sql += " and t.CREATE_TIME = ? ";
					param.add(m.get("CREATE_TIME").toString().trim());
				}
				if(StringUtil.isNotEmpty(m.get("UPDATE_TIME"))){
					sql += " and t.UPDATE_TIME = ? ";
					param.add(m.get("UPDATE_TIME").toString().trim());
				}
			
		}
		
		
		//排序
		if(StringUtil.isNotEmpty((String)m.get("sort"))){
			sql+=" order by " + m.get("sort").toString().toUpperCase() + " " +m.get("order").toString().toUpperCase();
		}
		
		
		System.out.println(sql);
		List l = this.pubDao.findBySqlToMap(sql,param.toArray(), p);	
		return l;

	};
	
	/*
	 * (non-Javadoc)
	 * @see cn.thd.service.se.SeRequirementTraceService#saveSeRequirementTrace(cn.thd.pojo.se.SeRequirementTrace)
	 */
	public void saveSeRequirementTrace(SeRequirementTrace obj) {
		obj.setCreateTime(new Date());
		obj.setUpdateTime(new Date());
		obj.setIsDelete(StaticVar.ISDELETE_UNDELETE);
		this.pubDao.save(obj);
	};
	/*
	 * (non-Javadoc)
	 * @see cn.thd.service.se.SeRequirementTraceService#updateSeRequirementTrace(cn.thd.pojo.se.SeRequirementTrace)
	 */
	public void updateSeRequirementTrace(SeRequirementTrace obj){
		obj.setUpdateTime(new Date());
		this.pubDao.update(obj);
	};

	/*
	 * (non-Javadoc)
	 * @see cn.thd.service.se.SeRequirementTraceService#querySeRequirementTraceById(java.lang.String)
	 */
	public SeRequirementTrace querySeRequirementTraceById(java.lang.String pk){
		return (SeRequirementTrace)this.pubDao.findById(SeRequirementTrace.class,pk);
	};
	
	/*
	 * (non-Javadoc)
	 * @see cn.thd.service.se.SeRequirementTraceService#deleteSeRequirementTraceById(java.lang.String)
	 */
	public void deleteSeRequirementTraceById(java.lang.String pk){
		SeRequirementTrace obj = this.querySeRequirementTraceById(pk);
		this.pubDao.delete(obj);
	};
	
	
	/**
	 * 批量删除跟踪矩阵树对象
	 * @param ids 主键,多个主键用","隔开
	 */
	public void deleteSeRequirementTraceByIds(String ids){
		if(ids!=null && !ids.trim().equals("")){
			String[] idArray = ids.split(",");
			if(idArray.length > 0){
				for(String id : idArray){
					if(id!=null &&  !id.trim().equals("")){
							deleteSeRequirementTraceById(id);
					}
				}
			}
		}
	};
	/**
	 * 获取某项目的需求矩阵所有节点
	 * @param projectId 项目ID
	 * @return
	 */
	public List<EasyUiTreeBean> queryTraceTreeData(String projectId,String treeCode){
		
		List<EasyUiTreeBean> r = new ArrayList<EasyUiTreeBean>();
		String sql = "select "+ 
				" t.trace_id as id,"+ 
				" t.trace_name as text, "+
				" t.tree_code as code " +
				" from se_requirement_trace t "+ 
				" where t.is_delete = ?  and t.tree_code like ? and t.tree_code not like ? ";
		List<String> param = new ArrayList<String>();
		param.add(StaticVar.ISDELETE_UNDELETE);
		
	
		
		String tc = "00000";
		if(MyStringUtils.isNotEmpty(treeCode)){
			tc = treeCode;
			param.add(tc + ".%");
			param.add(tc + ".%.%");
		}else{
			param.add(tc);
			param.add(tc + ".%");
		}
		
		if(MyStringUtils.isNotEmpty(projectId)){
			sql += " and t.project_id = ?";
			param.add(projectId);
		}
		
		
		
		List l = this.jdbcDao.query(sql, param.toArray(), null);
		if(MyListUtils.isNotEmpty(l)){
			for(Object obj : l){
				EasyUiTreeBean b = new EasyUiTreeBean();
				Map m = (Map)obj;
				String id = m.get("id") == null ? "" : m.get("id").toString();
				String text = m.get("text") == null ? "" : m.get("text").toString();
				String nodeCode = m.get("code") == null ? "" : m.get("code").toString();
				b.setId(id);
				b.setText(text);
				
				List childs = queryTraceTreeData(projectId,nodeCode);
				if(MyListUtils.isNotEmpty(childs)){
					b.setState("closed");
					b.setChildren(childs);
				}else{
					b.setState("open");
				}
				b.setChildren(childs);
				r.add(b);
			}
		}
		return r;
	};
	
	public List querySeRequirementTraceTaskUnion(String projectId){
		String sql = " select "
				+ " t.id as id,"
				+ " t.name as name,"
				+ " t.parentId as _parentId,"
				+ " t.isParent as parent,"
				+ " t.dataType as dataType,"
				+ " task.begin_date as beginDate,"
				+ " task.finish_date as finishDate,"
				+ " task.act_begin_date as actBeginDate,"
				+ " task.act_finish_date as actFinishDate,"
				+ " task.exec_note as execNote,"
				+ " task.current_process as currentProcess "
				+ " from view_trace_task_union t "
				+ " left join se_trace_task task on t.id = task.task_id"
				+ " where t.projectId = ? ";
		List params = new ArrayList();
		params.add(projectId);
		List l = this.jdbcDao.query(sql, params.toArray(), null);
		return l;
	};
	
	
	public List seRequirementTraceTaskUnionSearch(String keyWord,String projectId){
		String sql = " select t.id as id from view_trace_task_union t where t.projectId = ?  and upper(t.name) like upper(?) ";
		List params = new ArrayList();
		params.add(projectId);
		params.add("%" + keyWord.trim() + "%");
		List l = this.jdbcDao.query(sql, params.toArray(), null);
		return l;
	};
	
}
